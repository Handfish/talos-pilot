// This file is @generated by prost-build.
/// rpc applyConfiguration
/// ApplyConfiguration describes a request to assert a new configuration upon a
/// node.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyConfigurationRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "apply_configuration_request::Mode", tag = "4")]
    pub mode: i32,
    #[prost(bool, tag = "5")]
    pub dry_run: bool,
    #[prost(message, optional, tag = "6")]
    pub try_mode_timeout: ::core::option::Option<::prost_types::Duration>,
}
/// Nested message and enum types in `ApplyConfigurationRequest`.
pub mod apply_configuration_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        Reboot = 0,
        Auto = 1,
        NoReboot = 2,
        Staged = 3,
        Try = 4,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Reboot => "REBOOT",
                Self::Auto => "AUTO",
                Self::NoReboot => "NO_REBOOT",
                Self::Staged => "STAGED",
                Self::Try => "TRY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REBOOT" => Some(Self::Reboot),
                "AUTO" => Some(Self::Auto),
                "NO_REBOOT" => Some(Self::NoReboot),
                "STAGED" => Some(Self::Staged),
                "TRY" => Some(Self::Try),
                _ => None,
            }
        }
    }
}
/// ApplyConfigurationResponse describes the response to a configuration request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyConfiguration {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    /// Configuration validation warnings.
    #[prost(string, repeated, tag = "2")]
    pub warnings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// States which mode was actually chosen.
    #[prost(enumeration = "apply_configuration_request::Mode", tag = "3")]
    pub mode: i32,
    /// Human-readable message explaining the result of the apply configuration call.
    #[prost(string, tag = "4")]
    pub mode_details: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyConfigurationResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<ApplyConfiguration>,
}
/// rpc reboot
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RebootRequest {
    #[prost(enumeration = "reboot_request::Mode", tag = "1")]
    pub mode: i32,
}
/// Nested message and enum types in `RebootRequest`.
pub mod reboot_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        Default = 0,
        Powercycle = 1,
        Force = 2,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Default => "DEFAULT",
                Self::Powercycle => "POWERCYCLE",
                Self::Force => "FORCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEFAULT" => Some(Self::Default),
                "POWERCYCLE" => Some(Self::Powercycle),
                "FORCE" => Some(Self::Force),
                _ => None,
            }
        }
    }
}
/// The reboot message containing the reboot status.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reboot {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, tag = "2")]
    pub actor_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RebootResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Reboot>,
}
/// rpc Bootstrap
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BootstrapRequest {
    /// Enable etcd recovery from the snapshot.
    /// Snapshot should be uploaded before this call via EtcdRecover RPC.
    #[prost(bool, tag = "1")]
    pub recover_etcd: bool,
    /// Skip hash check on the snapshot (etcd).
    /// Enable this when recovering from data directory copy to skip integrity check.
    #[prost(bool, tag = "2")]
    pub recover_skip_hash_check: bool,
}
/// The bootstrap message containing the bootstrap status.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bootstrap {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BootstrapResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Bootstrap>,
}
/// rpc events
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SequenceEvent {
    #[prost(string, tag = "1")]
    pub sequence: ::prost::alloc::string::String,
    #[prost(enumeration = "sequence_event::Action", tag = "2")]
    pub action: i32,
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<super::common::Error>,
}
/// Nested message and enum types in `SequenceEvent`.
pub mod sequence_event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        Noop = 0,
        Start = 1,
        Stop = 2,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Noop => "NOOP",
                Self::Start => "START",
                Self::Stop => "STOP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NOOP" => Some(Self::Noop),
                "START" => Some(Self::Start),
                "STOP" => Some(Self::Stop),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PhaseEvent {
    #[prost(string, tag = "1")]
    pub phase: ::prost::alloc::string::String,
    #[prost(enumeration = "phase_event::Action", tag = "2")]
    pub action: i32,
}
/// Nested message and enum types in `PhaseEvent`.
pub mod phase_event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        Start = 0,
        Stop = 1,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Start => "START",
                Self::Stop => "STOP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "START" => Some(Self::Start),
                "STOP" => Some(Self::Stop),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskEvent {
    #[prost(string, tag = "1")]
    pub task: ::prost::alloc::string::String,
    #[prost(enumeration = "task_event::Action", tag = "2")]
    pub action: i32,
}
/// Nested message and enum types in `TaskEvent`.
pub mod task_event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        Start = 0,
        Stop = 1,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Start => "START",
                Self::Stop => "STOP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "START" => Some(Self::Start),
                "STOP" => Some(Self::Stop),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceStateEvent {
    #[prost(string, tag = "1")]
    pub service: ::prost::alloc::string::String,
    #[prost(enumeration = "service_state_event::Action", tag = "2")]
    pub action: i32,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub health: ::core::option::Option<ServiceHealth>,
}
/// Nested message and enum types in `ServiceStateEvent`.
pub mod service_state_event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        Initialized = 0,
        Preparing = 1,
        Waiting = 2,
        Running = 3,
        Stopping = 4,
        Finished = 5,
        Failed = 6,
        Skipped = 7,
        Starting = 8,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Initialized => "INITIALIZED",
                Self::Preparing => "PREPARING",
                Self::Waiting => "WAITING",
                Self::Running => "RUNNING",
                Self::Stopping => "STOPPING",
                Self::Finished => "FINISHED",
                Self::Failed => "FAILED",
                Self::Skipped => "SKIPPED",
                Self::Starting => "STARTING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INITIALIZED" => Some(Self::Initialized),
                "PREPARING" => Some(Self::Preparing),
                "WAITING" => Some(Self::Waiting),
                "RUNNING" => Some(Self::Running),
                "STOPPING" => Some(Self::Stopping),
                "FINISHED" => Some(Self::Finished),
                "FAILED" => Some(Self::Failed),
                "SKIPPED" => Some(Self::Skipped),
                "STARTING" => Some(Self::Starting),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RestartEvent {
    #[prost(int64, tag = "1")]
    pub cmd: i64,
}
/// ConfigLoadErrorEvent is reported when the config loading has failed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigLoadErrorEvent {
    #[prost(string, tag = "1")]
    pub error: ::prost::alloc::string::String,
}
/// ConfigValidationErrorEvent is reported when config validation has failed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigValidationErrorEvent {
    #[prost(string, tag = "1")]
    pub error: ::prost::alloc::string::String,
}
/// AddressEvent reports node endpoints aggregated from k8s.Endpoints and network.Hostname.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddressEvent {
    #[prost(string, tag = "1")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// MachineStatusEvent reports changes to the MachineStatus resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineStatusEvent {
    #[prost(enumeration = "machine_status_event::MachineStage", tag = "1")]
    pub stage: i32,
    #[prost(message, optional, tag = "2")]
    pub status: ::core::option::Option<machine_status_event::MachineStatus>,
}
/// Nested message and enum types in `MachineStatusEvent`.
pub mod machine_status_event {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MachineStatus {
        #[prost(bool, tag = "1")]
        pub ready: bool,
        #[prost(message, repeated, tag = "2")]
        pub unmet_conditions: ::prost::alloc::vec::Vec<machine_status::UnmetCondition>,
    }
    /// Nested message and enum types in `MachineStatus`.
    pub mod machine_status {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct UnmetCondition {
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub reason: ::prost::alloc::string::String,
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MachineStage {
        Unknown = 0,
        Booting = 1,
        Installing = 2,
        Maintenance = 3,
        Running = 4,
        Rebooting = 5,
        ShuttingDown = 6,
        Resetting = 7,
        Upgrading = 8,
    }
    impl MachineStage {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Booting => "BOOTING",
                Self::Installing => "INSTALLING",
                Self::Maintenance => "MAINTENANCE",
                Self::Running => "RUNNING",
                Self::Rebooting => "REBOOTING",
                Self::ShuttingDown => "SHUTTING_DOWN",
                Self::Resetting => "RESETTING",
                Self::Upgrading => "UPGRADING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "BOOTING" => Some(Self::Booting),
                "INSTALLING" => Some(Self::Installing),
                "MAINTENANCE" => Some(Self::Maintenance),
                "RUNNING" => Some(Self::Running),
                "REBOOTING" => Some(Self::Rebooting),
                "SHUTTING_DOWN" => Some(Self::ShuttingDown),
                "RESETTING" => Some(Self::Resetting),
                "UPGRADING" => Some(Self::Upgrading),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventsRequest {
    #[prost(int32, tag = "1")]
    pub tail_events: i32,
    #[prost(string, tag = "2")]
    pub tail_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub tail_seconds: i32,
    #[prost(string, tag = "4")]
    pub with_actor_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, optional, tag = "2")]
    pub data: ::core::option::Option<::prost_types::Any>,
    #[prost(string, tag = "3")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub actor_id: ::prost::alloc::string::String,
}
/// rpc reset
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetPartitionSpec {
    #[prost(string, tag = "1")]
    pub label: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub wipe: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetRequest {
    /// Graceful indicates whether node should leave etcd before the upgrade, it also
    /// enforces etcd checks before leaving.
    #[prost(bool, tag = "1")]
    pub graceful: bool,
    /// Reboot indicates whether node should reboot or halt after resetting.
    #[prost(bool, tag = "2")]
    pub reboot: bool,
    /// System_partitions_to_wipe lists specific system disk partitions to be reset (wiped).
    /// If system_partitions_to_wipe is empty, all the partitions are erased.
    #[prost(message, repeated, tag = "3")]
    pub system_partitions_to_wipe: ::prost::alloc::vec::Vec<ResetPartitionSpec>,
    /// UserDisksToWipe lists specific connected block devices to be reset (wiped).
    #[prost(string, repeated, tag = "4")]
    pub user_disks_to_wipe: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// WipeMode defines which devices should be wiped.
    #[prost(enumeration = "reset_request::WipeMode", tag = "5")]
    pub mode: i32,
}
/// Nested message and enum types in `ResetRequest`.
pub mod reset_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WipeMode {
        All = 0,
        SystemDisk = 1,
        UserDisks = 2,
    }
    impl WipeMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::All => "ALL",
                Self::SystemDisk => "SYSTEM_DISK",
                Self::UserDisks => "USER_DISKS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ALL" => Some(Self::All),
                "SYSTEM_DISK" => Some(Self::SystemDisk),
                "USER_DISKS" => Some(Self::UserDisks),
                _ => None,
            }
        }
    }
}
/// The reset message containing the restart status.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reset {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, tag = "2")]
    pub actor_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Reset>,
}
/// rpc shutdown
/// The messages message containing the shutdown status.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Shutdown {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, tag = "2")]
    pub actor_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShutdownRequest {
    /// Force indicates whether node should shutdown without first cordening and draining
    #[prost(bool, tag = "1")]
    pub force: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShutdownResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Shutdown>,
}
/// rpc upgrade
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeRequest {
    #[prost(string, tag = "1")]
    pub image: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub preserve: bool,
    #[prost(bool, tag = "3")]
    pub stage: bool,
    #[prost(bool, tag = "4")]
    pub force: bool,
    #[prost(enumeration = "upgrade_request::RebootMode", tag = "5")]
    pub reboot_mode: i32,
}
/// Nested message and enum types in `UpgradeRequest`.
pub mod upgrade_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RebootMode {
        Default = 0,
        Powercycle = 1,
    }
    impl RebootMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Default => "DEFAULT",
                Self::Powercycle => "POWERCYCLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEFAULT" => Some(Self::Default),
                "POWERCYCLE" => Some(Self::Powercycle),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Upgrade {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, tag = "2")]
    pub ack: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub actor_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Upgrade>,
}
/// rpc servicelist
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceList {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, repeated, tag = "2")]
    pub services: ::prost::alloc::vec::Vec<ServiceInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceListResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<ServiceList>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceInfo {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub state: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub events: ::core::option::Option<ServiceEvents>,
    #[prost(message, optional, tag = "4")]
    pub health: ::core::option::Option<ServiceHealth>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceEvents {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<ServiceEvent>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceEvent {
    #[prost(string, tag = "1")]
    pub msg: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub state: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub ts: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceHealth {
    #[prost(bool, tag = "1")]
    pub unknown: bool,
    #[prost(bool, tag = "2")]
    pub healthy: bool,
    #[prost(string, tag = "3")]
    pub last_message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub last_change: ::core::option::Option<::prost_types::Timestamp>,
}
/// rpc servicestart
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceStartRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceStart {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, tag = "2")]
    pub resp: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceStartResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<ServiceStart>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceStopRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceStop {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, tag = "2")]
    pub resp: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceStopResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<ServiceStop>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceRestartRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceRestart {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, tag = "2")]
    pub resp: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceRestartResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<ServiceRestart>,
}
/// CopyRequest describes a request to copy data out of Talos node
///
/// Copy produces .tar.gz archive which is streamed back to the caller
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CopyRequest {
    /// Root path to start copying data out, it might be either a file or directory
    #[prost(string, tag = "1")]
    pub root_path: ::prost::alloc::string::String,
}
/// ListRequest describes a request to list the contents of a directory.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRequest {
    /// Root indicates the root directory for the list. If not indicated, '/' is
    /// presumed.
    #[prost(string, tag = "1")]
    pub root: ::prost::alloc::string::String,
    /// Recurse indicates that subdirectories should be recursed.
    #[prost(bool, tag = "2")]
    pub recurse: bool,
    /// RecursionDepth indicates how many levels of subdirectories should be
    /// recursed. The default (0) indicates that no limit should be enforced.
    #[prost(int32, tag = "3")]
    pub recursion_depth: i32,
    /// Types indicates what file type should be returned. If not indicated,
    /// all files will be returned.
    #[prost(enumeration = "list_request::Type", repeated, tag = "4")]
    pub types: ::prost::alloc::vec::Vec<i32>,
    /// Report xattrs
    #[prost(bool, tag = "5")]
    pub report_xattrs: bool,
}
/// Nested message and enum types in `ListRequest`.
pub mod list_request {
    /// File type.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Regular file (not directory, symlink, etc).
        Regular = 0,
        /// Directory.
        Directory = 1,
        /// Symbolic link.
        Symlink = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Regular => "REGULAR",
                Self::Directory => "DIRECTORY",
                Self::Symlink => "SYMLINK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REGULAR" => Some(Self::Regular),
                "DIRECTORY" => Some(Self::Directory),
                "SYMLINK" => Some(Self::Symlink),
                _ => None,
            }
        }
    }
}
/// DiskUsageRequest describes a request to list disk usage of directories and regular files
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskUsageRequest {
    /// RecursionDepth indicates how many levels of subdirectories should be
    /// recursed. The default (0) indicates that no limit should be enforced.
    #[prost(int32, tag = "1")]
    pub recursion_depth: i32,
    /// All write sizes for all files, not just directories.
    #[prost(bool, tag = "2")]
    pub all: bool,
    /// Threshold exclude entries smaller than SIZE if positive,
    /// or entries greater than SIZE if negative.
    #[prost(int64, tag = "3")]
    pub threshold: i64,
    /// DiskUsagePaths is the list of directories to calculate disk usage for.
    #[prost(string, repeated, tag = "4")]
    pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// FileInfo describes a file or directory's information
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileInfo {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    /// Name is the name (including prefixed path) of the file or directory
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Size indicates the number of bytes contained within the file
    #[prost(int64, tag = "3")]
    pub size: i64,
    /// Mode is the bitmap of UNIX mode/permission flags of the file
    #[prost(uint32, tag = "4")]
    pub mode: u32,
    /// Modified indicates the UNIX timestamp at which the file was last modified
    #[prost(int64, tag = "5")]
    pub modified: i64,
    /// IsDir indicates that the file is a directory
    #[prost(bool, tag = "6")]
    pub is_dir: bool,
    /// Error describes any error encountered while trying to read the file
    /// information.
    #[prost(string, tag = "7")]
    pub error: ::prost::alloc::string::String,
    /// Link is filled with symlink target
    #[prost(string, tag = "8")]
    pub link: ::prost::alloc::string::String,
    /// RelativeName is the name of the file or directory relative to the RootPath
    #[prost(string, tag = "9")]
    pub relative_name: ::prost::alloc::string::String,
    /// Owner uid
    #[prost(uint32, tag = "10")]
    pub uid: u32,
    /// Owner gid
    #[prost(uint32, tag = "11")]
    pub gid: u32,
    /// Extended attributes (if present and requested)
    #[prost(message, repeated, tag = "12")]
    pub xattrs: ::prost::alloc::vec::Vec<Xattr>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Xattr {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// DiskUsageInfo describes a file or directory's information for du command
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskUsageInfo {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    /// Name is the name (including prefixed path) of the file or directory
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Size indicates the number of bytes contained within the file
    #[prost(int64, tag = "3")]
    pub size: i64,
    /// Error describes any error encountered while trying to read the file
    /// information.
    #[prost(string, tag = "4")]
    pub error: ::prost::alloc::string::String,
    /// RelativeName is the name of the file or directory relative to the RootPath
    #[prost(string, tag = "5")]
    pub relative_name: ::prost::alloc::string::String,
}
/// The messages message containing the requested df stats.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Mounts {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, repeated, tag = "2")]
    pub stats: ::prost::alloc::vec::Vec<MountStat>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MountsResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Mounts>,
}
/// The messages message containing the requested processes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MountStat {
    #[prost(string, tag = "1")]
    pub filesystem: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub size: u64,
    #[prost(uint64, tag = "3")]
    pub available: u64,
    #[prost(string, tag = "4")]
    pub mounted_on: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Version {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, optional, tag = "2")]
    pub version: ::core::option::Option<VersionInfo>,
    #[prost(message, optional, tag = "3")]
    pub platform: ::core::option::Option<PlatformInfo>,
    /// Features describe individual Talos features that can be switched on or off.
    #[prost(message, optional, tag = "4")]
    pub features: ::core::option::Option<FeaturesInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VersionResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Version>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VersionInfo {
    #[prost(string, tag = "1")]
    pub tag: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub sha: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub built: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub go_version: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub os: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub arch: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlatformInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub mode: ::prost::alloc::string::String,
}
/// FeaturesInfo describes individual Talos features that can be switched on or off.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeaturesInfo {
    /// RBAC is true if role-based access control is enabled.
    #[prost(bool, tag = "1")]
    pub rbac: bool,
}
/// rpc logs
/// The request message containing the process name.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogsRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    /// driver might be default "containerd" or "cri"
    #[prost(enumeration = "super::common::ContainerDriver", tag = "3")]
    pub driver: i32,
    #[prost(bool, tag = "4")]
    pub follow: bool,
    #[prost(int32, tag = "5")]
    pub tail_lines: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadRequest {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
}
/// LogsContainer desribes all avalaible registered log containers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogsContainer {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, repeated, tag = "2")]
    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogsContainersResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<LogsContainer>,
}
/// rpc rollback
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RollbackRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rollback {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RollbackResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Rollback>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContainersRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// driver might be default "containerd" or "cri"
    #[prost(enumeration = "super::common::ContainerDriver", tag = "2")]
    pub driver: i32,
}
/// The messages message containing the requested containers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContainerInfo {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub internal_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub image: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub pid: u32,
    #[prost(string, tag = "5")]
    pub status: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub pod_id: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub network_namespace: ::prost::alloc::string::String,
}
/// The messages message containing the requested containers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Container {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, repeated, tag = "2")]
    pub containers: ::prost::alloc::vec::Vec<ContainerInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContainersResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Container>,
}
/// dmesg
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DmesgRequest {
    #[prost(bool, tag = "1")]
    pub follow: bool,
    #[prost(bool, tag = "2")]
    pub tail: bool,
}
/// rpc processes
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessesResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Process>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Process {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, repeated, tag = "2")]
    pub processes: ::prost::alloc::vec::Vec<ProcessInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessInfo {
    #[prost(int32, tag = "1")]
    pub pid: i32,
    #[prost(int32, tag = "2")]
    pub ppid: i32,
    #[prost(string, tag = "3")]
    pub state: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub threads: i32,
    #[prost(double, tag = "5")]
    pub cpu_time: f64,
    #[prost(uint64, tag = "6")]
    pub virtual_memory: u64,
    #[prost(uint64, tag = "7")]
    pub resident_memory: u64,
    #[prost(string, tag = "8")]
    pub command: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub executable: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub args: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub label: ::prost::alloc::string::String,
}
/// rpc restart
/// The request message containing the process to restart.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    /// driver might be default "containerd" or "cri"
    #[prost(enumeration = "super::common::ContainerDriver", tag = "3")]
    pub driver: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Restart {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
/// The messages message containing the restart status.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Restart>,
}
/// The request message containing the containerd namespace.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// driver might be default "containerd" or "cri"
    #[prost(enumeration = "super::common::ContainerDriver", tag = "2")]
    pub driver: i32,
}
/// The messages message containing the requested stats.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stats {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, repeated, tag = "2")]
    pub stats: ::prost::alloc::vec::Vec<Stat>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Stats>,
}
/// The messages message containing the requested stat.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stat {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub memory_usage: u64,
    #[prost(uint64, tag = "5")]
    pub cpu_usage: u64,
    #[prost(string, tag = "6")]
    pub pod_id: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Memory {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, optional, tag = "2")]
    pub meminfo: ::core::option::Option<MemInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemoryResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Memory>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MemInfo {
    #[prost(uint64, tag = "1")]
    pub memtotal: u64,
    #[prost(uint64, tag = "2")]
    pub memfree: u64,
    #[prost(uint64, tag = "3")]
    pub memavailable: u64,
    #[prost(uint64, tag = "4")]
    pub buffers: u64,
    #[prost(uint64, tag = "5")]
    pub cached: u64,
    #[prost(uint64, tag = "6")]
    pub swapcached: u64,
    #[prost(uint64, tag = "7")]
    pub active: u64,
    #[prost(uint64, tag = "8")]
    pub inactive: u64,
    #[prost(uint64, tag = "9")]
    pub activeanon: u64,
    #[prost(uint64, tag = "10")]
    pub inactiveanon: u64,
    #[prost(uint64, tag = "11")]
    pub activefile: u64,
    #[prost(uint64, tag = "12")]
    pub inactivefile: u64,
    #[prost(uint64, tag = "13")]
    pub unevictable: u64,
    #[prost(uint64, tag = "14")]
    pub mlocked: u64,
    #[prost(uint64, tag = "15")]
    pub swaptotal: u64,
    #[prost(uint64, tag = "16")]
    pub swapfree: u64,
    #[prost(uint64, tag = "17")]
    pub dirty: u64,
    #[prost(uint64, tag = "18")]
    pub writeback: u64,
    #[prost(uint64, tag = "19")]
    pub anonpages: u64,
    #[prost(uint64, tag = "20")]
    pub mapped: u64,
    #[prost(uint64, tag = "21")]
    pub shmem: u64,
    #[prost(uint64, tag = "22")]
    pub slab: u64,
    #[prost(uint64, tag = "23")]
    pub sreclaimable: u64,
    #[prost(uint64, tag = "24")]
    pub sunreclaim: u64,
    #[prost(uint64, tag = "25")]
    pub kernelstack: u64,
    #[prost(uint64, tag = "26")]
    pub pagetables: u64,
    #[prost(uint64, tag = "27")]
    pub nfsunstable: u64,
    #[prost(uint64, tag = "28")]
    pub bounce: u64,
    #[prost(uint64, tag = "29")]
    pub writebacktmp: u64,
    #[prost(uint64, tag = "30")]
    pub commitlimit: u64,
    #[prost(uint64, tag = "31")]
    pub committedas: u64,
    #[prost(uint64, tag = "32")]
    pub vmalloctotal: u64,
    #[prost(uint64, tag = "33")]
    pub vmallocused: u64,
    #[prost(uint64, tag = "34")]
    pub vmallocchunk: u64,
    #[prost(uint64, tag = "35")]
    pub hardwarecorrupted: u64,
    #[prost(uint64, tag = "36")]
    pub anonhugepages: u64,
    #[prost(uint64, tag = "37")]
    pub shmemhugepages: u64,
    #[prost(uint64, tag = "38")]
    pub shmempmdmapped: u64,
    #[prost(uint64, tag = "39")]
    pub cmatotal: u64,
    #[prost(uint64, tag = "40")]
    pub cmafree: u64,
    #[prost(uint64, tag = "41")]
    pub hugepagestotal: u64,
    #[prost(uint64, tag = "42")]
    pub hugepagesfree: u64,
    #[prost(uint64, tag = "43")]
    pub hugepagesrsvd: u64,
    #[prost(uint64, tag = "44")]
    pub hugepagessurp: u64,
    #[prost(uint64, tag = "45")]
    pub hugepagesize: u64,
    #[prost(uint64, tag = "46")]
    pub directmap4k: u64,
    #[prost(uint64, tag = "47")]
    pub directmap2m: u64,
    #[prost(uint64, tag = "48")]
    pub directmap1g: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HostnameResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Hostname>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Hostname {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, tag = "2")]
    pub hostname: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadAvgResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<LoadAvg>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadAvg {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(double, tag = "2")]
    pub load1: f64,
    #[prost(double, tag = "3")]
    pub load5: f64,
    #[prost(double, tag = "4")]
    pub load15: f64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemStatResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<SystemStat>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemStat {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(uint64, tag = "2")]
    pub boot_time: u64,
    #[prost(message, optional, tag = "3")]
    pub cpu_total: ::core::option::Option<CpuStat>,
    #[prost(message, repeated, tag = "4")]
    pub cpu: ::prost::alloc::vec::Vec<CpuStat>,
    #[prost(uint64, tag = "5")]
    pub irq_total: u64,
    #[prost(uint64, repeated, tag = "6")]
    pub irq: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, tag = "7")]
    pub context_switches: u64,
    #[prost(uint64, tag = "8")]
    pub process_created: u64,
    #[prost(uint64, tag = "9")]
    pub process_running: u64,
    #[prost(uint64, tag = "10")]
    pub process_blocked: u64,
    #[prost(uint64, tag = "11")]
    pub soft_irq_total: u64,
    #[prost(message, optional, tag = "12")]
    pub soft_irq: ::core::option::Option<SoftIrqStat>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CpuStat {
    #[prost(double, tag = "1")]
    pub user: f64,
    #[prost(double, tag = "2")]
    pub nice: f64,
    #[prost(double, tag = "3")]
    pub system: f64,
    #[prost(double, tag = "4")]
    pub idle: f64,
    #[prost(double, tag = "5")]
    pub iowait: f64,
    #[prost(double, tag = "6")]
    pub irq: f64,
    #[prost(double, tag = "7")]
    pub soft_irq: f64,
    #[prost(double, tag = "8")]
    pub steal: f64,
    #[prost(double, tag = "9")]
    pub guest: f64,
    #[prost(double, tag = "10")]
    pub guest_nice: f64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SoftIrqStat {
    #[prost(uint64, tag = "1")]
    pub hi: u64,
    #[prost(uint64, tag = "2")]
    pub timer: u64,
    #[prost(uint64, tag = "3")]
    pub net_tx: u64,
    #[prost(uint64, tag = "4")]
    pub net_rx: u64,
    #[prost(uint64, tag = "5")]
    pub block: u64,
    #[prost(uint64, tag = "6")]
    pub block_io_poll: u64,
    #[prost(uint64, tag = "7")]
    pub tasklet: u64,
    #[prost(uint64, tag = "8")]
    pub sched: u64,
    #[prost(uint64, tag = "9")]
    pub hrtimer: u64,
    #[prost(uint64, tag = "10")]
    pub rcu: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CpuFreqStatsResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<CpUsFreqStats>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CpUsFreqStats {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, repeated, tag = "2")]
    pub cpu_freq_stats: ::prost::alloc::vec::Vec<CpuFreqStats>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CpuFreqStats {
    #[prost(uint64, tag = "1")]
    pub current_frequency: u64,
    #[prost(uint64, tag = "2")]
    pub minimum_frequency: u64,
    #[prost(uint64, tag = "3")]
    pub maximum_frequency: u64,
    #[prost(string, tag = "4")]
    pub governor: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CpuInfoResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<CpUsInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CpUsInfo {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, repeated, tag = "2")]
    pub cpu_info: ::prost::alloc::vec::Vec<CpuInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CpuInfo {
    #[prost(uint32, tag = "1")]
    pub processor: u32,
    #[prost(string, tag = "2")]
    pub vendor_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub cpu_family: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub model: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub model_name: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub stepping: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub microcode: ::prost::alloc::string::String,
    #[prost(double, tag = "8")]
    pub cpu_mhz: f64,
    #[prost(string, tag = "9")]
    pub cache_size: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub physical_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "11")]
    pub siblings: u32,
    #[prost(string, tag = "12")]
    pub core_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "13")]
    pub cpu_cores: u32,
    #[prost(string, tag = "14")]
    pub apic_id: ::prost::alloc::string::String,
    #[prost(string, tag = "15")]
    pub initial_apic_id: ::prost::alloc::string::String,
    #[prost(string, tag = "16")]
    pub fpu: ::prost::alloc::string::String,
    #[prost(string, tag = "17")]
    pub fpu_exception: ::prost::alloc::string::String,
    #[prost(uint32, tag = "18")]
    pub cpu_id_level: u32,
    #[prost(string, tag = "19")]
    pub wp: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "20")]
    pub flags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "21")]
    pub bugs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(double, tag = "22")]
    pub bogo_mips: f64,
    #[prost(uint32, tag = "23")]
    pub cl_flush_size: u32,
    #[prost(uint32, tag = "24")]
    pub cache_alignment: u32,
    #[prost(string, tag = "25")]
    pub address_sizes: ::prost::alloc::string::String,
    #[prost(string, tag = "26")]
    pub power_management: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkDeviceStatsResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<NetworkDeviceStats>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkDeviceStats {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, optional, tag = "2")]
    pub total: ::core::option::Option<NetDev>,
    #[prost(message, repeated, tag = "3")]
    pub devices: ::prost::alloc::vec::Vec<NetDev>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetDev {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub rx_bytes: u64,
    #[prost(uint64, tag = "3")]
    pub rx_packets: u64,
    #[prost(uint64, tag = "4")]
    pub rx_errors: u64,
    #[prost(uint64, tag = "5")]
    pub rx_dropped: u64,
    #[prost(uint64, tag = "6")]
    pub rx_fifo: u64,
    #[prost(uint64, tag = "7")]
    pub rx_frame: u64,
    #[prost(uint64, tag = "8")]
    pub rx_compressed: u64,
    #[prost(uint64, tag = "9")]
    pub rx_multicast: u64,
    #[prost(uint64, tag = "10")]
    pub tx_bytes: u64,
    #[prost(uint64, tag = "11")]
    pub tx_packets: u64,
    #[prost(uint64, tag = "12")]
    pub tx_errors: u64,
    #[prost(uint64, tag = "13")]
    pub tx_dropped: u64,
    #[prost(uint64, tag = "14")]
    pub tx_fifo: u64,
    #[prost(uint64, tag = "15")]
    pub tx_collisions: u64,
    #[prost(uint64, tag = "16")]
    pub tx_carrier: u64,
    #[prost(uint64, tag = "17")]
    pub tx_compressed: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskStatsResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<DiskStats>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskStats {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, optional, tag = "2")]
    pub total: ::core::option::Option<DiskStat>,
    #[prost(message, repeated, tag = "3")]
    pub devices: ::prost::alloc::vec::Vec<DiskStat>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskStat {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub read_completed: u64,
    #[prost(uint64, tag = "3")]
    pub read_merged: u64,
    #[prost(uint64, tag = "4")]
    pub read_sectors: u64,
    #[prost(uint64, tag = "5")]
    pub read_time_ms: u64,
    #[prost(uint64, tag = "6")]
    pub write_completed: u64,
    #[prost(uint64, tag = "7")]
    pub write_merged: u64,
    #[prost(uint64, tag = "8")]
    pub write_sectors: u64,
    #[prost(uint64, tag = "9")]
    pub write_time_ms: u64,
    #[prost(uint64, tag = "10")]
    pub io_in_progress: u64,
    #[prost(uint64, tag = "11")]
    pub io_time_ms: u64,
    #[prost(uint64, tag = "12")]
    pub io_time_weighted_ms: u64,
    #[prost(uint64, tag = "13")]
    pub discard_completed: u64,
    #[prost(uint64, tag = "14")]
    pub discard_merged: u64,
    #[prost(uint64, tag = "15")]
    pub discard_sectors: u64,
    #[prost(uint64, tag = "16")]
    pub discard_time_ms: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EtcdLeaveClusterRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdLeaveCluster {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdLeaveClusterResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdLeaveCluster>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdRemoveMemberRequest {
    #[prost(string, tag = "1")]
    pub member: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdRemoveMember {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdRemoveMemberResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdRemoveMember>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EtcdRemoveMemberByIdRequest {
    #[prost(uint64, tag = "1")]
    pub member_id: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdRemoveMemberById {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdRemoveMemberByIdResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdRemoveMemberById>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EtcdForfeitLeadershipRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdForfeitLeadership {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, tag = "2")]
    pub member: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdForfeitLeadershipResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdForfeitLeadership>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EtcdMemberListRequest {
    #[prost(bool, tag = "1")]
    pub query_local: bool,
}
/// EtcdMember describes a single etcd member.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdMember {
    /// member ID.
    #[prost(uint64, tag = "2")]
    pub id: u64,
    /// human-readable name of the member.
    #[prost(string, tag = "3")]
    pub hostname: ::prost::alloc::string::String,
    /// the list of URLs the member exposes to clients for communication.
    #[prost(string, repeated, tag = "4")]
    pub peer_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// the list of URLs the member exposes to the cluster for communication.
    #[prost(string, repeated, tag = "5")]
    pub client_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// learner flag
    #[prost(bool, tag = "6")]
    pub is_learner: bool,
}
/// EtcdMembers contains the list of members registered on the host.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdMembers {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    /// list of member hostnames.
    #[prost(string, repeated, tag = "2")]
    pub legacy_members: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// the list of etcd members registered on the node.
    #[prost(message, repeated, tag = "3")]
    pub members: ::prost::alloc::vec::Vec<EtcdMember>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdMemberListResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdMembers>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EtcdSnapshotRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdRecover {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdRecoverResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdRecover>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdAlarmListResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdAlarm>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdAlarm {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, repeated, tag = "2")]
    pub member_alarms: ::prost::alloc::vec::Vec<EtcdMemberAlarm>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EtcdMemberAlarm {
    #[prost(uint64, tag = "1")]
    pub member_id: u64,
    #[prost(enumeration = "etcd_member_alarm::AlarmType", tag = "2")]
    pub alarm: i32,
}
/// Nested message and enum types in `EtcdMemberAlarm`.
pub mod etcd_member_alarm {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AlarmType {
        None = 0,
        Nospace = 1,
        Corrupt = 2,
    }
    impl AlarmType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::Nospace => "NOSPACE",
                Self::Corrupt => "CORRUPT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "NOSPACE" => Some(Self::Nospace),
                "CORRUPT" => Some(Self::Corrupt),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdAlarmDisarmResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdAlarmDisarm>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdAlarmDisarm {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, repeated, tag = "2")]
    pub member_alarms: ::prost::alloc::vec::Vec<EtcdMemberAlarm>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdDefragmentResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdDefragment>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdDefragment {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdStatusResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdStatus>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdStatus {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, optional, tag = "2")]
    pub member_status: ::core::option::Option<EtcdMemberStatus>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdMemberStatus {
    #[prost(string, tag = "11")]
    pub storage_version: ::prost::alloc::string::String,
    #[prost(uint64, tag = "10")]
    pub member_id: u64,
    #[prost(string, tag = "1")]
    pub protocol_version: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub db_size: i64,
    #[prost(int64, tag = "3")]
    pub db_size_in_use: i64,
    #[prost(uint64, tag = "4")]
    pub leader: u64,
    #[prost(uint64, tag = "5")]
    pub raft_index: u64,
    #[prost(uint64, tag = "6")]
    pub raft_term: u64,
    #[prost(uint64, tag = "7")]
    pub raft_applied_index: u64,
    #[prost(string, repeated, tag = "8")]
    pub errors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "9")]
    pub is_learner: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdDowngradeValidateRequest {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdDowngradeValidateResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdDowngradeValidate>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdDowngradeValidate {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, optional, tag = "2")]
    pub cluster_downgrade: ::core::option::Option<EtcdClusterDowngrade>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdDowngradeEnableRequest {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdDowngradeEnableResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdDowngradeEnable>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdDowngradeEnable {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, optional, tag = "2")]
    pub cluster_downgrade: ::core::option::Option<EtcdClusterDowngrade>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdDowngradeCancelResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdDowngradeCancel>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdDowngradeCancel {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, optional, tag = "2")]
    pub cluster_downgrade: ::core::option::Option<EtcdClusterDowngrade>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdClusterDowngrade {
    #[prost(string, tag = "1")]
    pub cluster_version: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteConfig {
    #[prost(string, tag = "1")]
    pub network: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub gateway: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub metric: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DhcpOptionsConfig {
    #[prost(uint32, tag = "1")]
    pub route_metric: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkDeviceConfig {
    #[prost(string, tag = "1")]
    pub interface: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub cidr: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub mtu: i32,
    #[prost(bool, tag = "4")]
    pub dhcp: bool,
    #[prost(bool, tag = "5")]
    pub ignore: bool,
    #[prost(message, optional, tag = "6")]
    pub dhcp_options: ::core::option::Option<DhcpOptionsConfig>,
    #[prost(message, repeated, tag = "7")]
    pub routes: ::prost::alloc::vec::Vec<RouteConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkConfig {
    #[prost(string, tag = "1")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub interfaces: ::prost::alloc::vec::Vec<NetworkDeviceConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallConfig {
    #[prost(string, tag = "1")]
    pub install_disk: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub install_image: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineConfig {
    #[prost(enumeration = "machine_config::MachineType", tag = "1")]
    pub r#type: i32,
    #[prost(message, optional, tag = "2")]
    pub install_config: ::core::option::Option<InstallConfig>,
    #[prost(message, optional, tag = "3")]
    pub network_config: ::core::option::Option<NetworkConfig>,
    #[prost(string, tag = "4")]
    pub kubernetes_version: ::prost::alloc::string::String,
}
/// Nested message and enum types in `MachineConfig`.
pub mod machine_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MachineType {
        TypeUnknown = 0,
        TypeInit = 1,
        TypeControlPlane = 2,
        TypeWorker = 3,
    }
    impl MachineType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::TypeUnknown => "TYPE_UNKNOWN",
                Self::TypeInit => "TYPE_INIT",
                Self::TypeControlPlane => "TYPE_CONTROL_PLANE",
                Self::TypeWorker => "TYPE_WORKER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNKNOWN" => Some(Self::TypeUnknown),
                "TYPE_INIT" => Some(Self::TypeInit),
                "TYPE_CONTROL_PLANE" => Some(Self::TypeControlPlane),
                "TYPE_WORKER" => Some(Self::TypeWorker),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ControlPlaneConfig {
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CniConfig {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterNetworkConfig {
    #[prost(string, tag = "1")]
    pub dns_domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub cni_config: ::core::option::Option<CniConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterConfig {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub control_plane: ::core::option::Option<ControlPlaneConfig>,
    #[prost(message, optional, tag = "3")]
    pub cluster_network: ::core::option::Option<ClusterNetworkConfig>,
    #[prost(bool, tag = "4")]
    pub allow_scheduling_on_control_planes: bool,
}
/// GenerateConfigurationRequest describes a request to generate a new configuration
/// on a node.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateConfigurationRequest {
    #[prost(string, tag = "1")]
    pub config_version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub cluster_config: ::core::option::Option<ClusterConfig>,
    #[prost(message, optional, tag = "3")]
    pub machine_config: ::core::option::Option<MachineConfig>,
    #[prost(message, optional, tag = "4")]
    pub override_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// GenerateConfiguration describes the response to a generate configuration request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateConfiguration {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub data: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", tag = "3")]
    pub talosconfig: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateConfigurationResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<GenerateConfiguration>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateClientConfigurationRequest {
    /// Roles in the generated client certificate.
    #[prost(string, repeated, tag = "1")]
    pub roles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Client certificate TTL.
    #[prost(message, optional, tag = "2")]
    pub crt_ttl: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateClientConfiguration {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    /// PEM-encoded CA certificate.
    #[prost(bytes = "vec", tag = "2")]
    pub ca: ::prost::alloc::vec::Vec<u8>,
    /// PEM-encoded generated client certificate.
    #[prost(bytes = "vec", tag = "3")]
    pub crt: ::prost::alloc::vec::Vec<u8>,
    /// PEM-encoded generated client key.
    #[prost(bytes = "vec", tag = "4")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    /// Client configuration (talosconfig) file content.
    #[prost(bytes = "vec", tag = "5")]
    pub talosconfig: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateClientConfigurationResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<GenerateClientConfiguration>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PacketCaptureRequest {
    /// Interface name to perform packet capture on.
    #[prost(string, tag = "1")]
    pub interface: ::prost::alloc::string::String,
    /// Enable promiscuous mode.
    #[prost(bool, tag = "2")]
    pub promiscuous: bool,
    /// Snap length in bytes.
    #[prost(uint32, tag = "3")]
    pub snap_len: u32,
    /// BPF filter.
    #[prost(message, repeated, tag = "4")]
    pub bpf_filter: ::prost::alloc::vec::Vec<BpfInstruction>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BpfInstruction {
    #[prost(uint32, tag = "1")]
    pub op: u32,
    #[prost(uint32, tag = "2")]
    pub jt: u32,
    #[prost(uint32, tag = "3")]
    pub jf: u32,
    #[prost(uint32, tag = "4")]
    pub k: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetstatRequest {
    #[prost(enumeration = "netstat_request::Filter", tag = "1")]
    pub filter: i32,
    #[prost(message, optional, tag = "2")]
    pub feature: ::core::option::Option<netstat_request::Feature>,
    #[prost(message, optional, tag = "3")]
    pub l4proto: ::core::option::Option<netstat_request::L4proto>,
    #[prost(message, optional, tag = "4")]
    pub netns: ::core::option::Option<netstat_request::NetNs>,
}
/// Nested message and enum types in `NetstatRequest`.
pub mod netstat_request {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Feature {
        #[prost(bool, tag = "1")]
        pub pid: bool,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct L4proto {
        #[prost(bool, tag = "1")]
        pub tcp: bool,
        #[prost(bool, tag = "2")]
        pub tcp6: bool,
        #[prost(bool, tag = "3")]
        pub udp: bool,
        #[prost(bool, tag = "4")]
        pub udp6: bool,
        #[prost(bool, tag = "5")]
        pub udplite: bool,
        #[prost(bool, tag = "6")]
        pub udplite6: bool,
        #[prost(bool, tag = "7")]
        pub raw: bool,
        #[prost(bool, tag = "8")]
        pub raw6: bool,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NetNs {
        #[prost(bool, tag = "1")]
        pub hostnetwork: bool,
        #[prost(string, repeated, tag = "2")]
        pub netns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(bool, tag = "3")]
        pub allnetns: bool,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Filter {
        All = 0,
        Connected = 1,
        Listening = 2,
    }
    impl Filter {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::All => "ALL",
                Self::Connected => "CONNECTED",
                Self::Listening => "LISTENING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ALL" => Some(Self::All),
                "CONNECTED" => Some(Self::Connected),
                "LISTENING" => Some(Self::Listening),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectRecord {
    #[prost(string, tag = "1")]
    pub l4proto: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub localip: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub localport: u32,
    #[prost(string, tag = "4")]
    pub remoteip: ::prost::alloc::string::String,
    #[prost(uint32, tag = "5")]
    pub remoteport: u32,
    #[prost(enumeration = "connect_record::State", tag = "6")]
    pub state: i32,
    #[prost(uint64, tag = "7")]
    pub txqueue: u64,
    #[prost(uint64, tag = "8")]
    pub rxqueue: u64,
    #[prost(enumeration = "connect_record::TimerActive", tag = "9")]
    pub tr: i32,
    #[prost(uint64, tag = "10")]
    pub timerwhen: u64,
    #[prost(uint64, tag = "11")]
    pub retrnsmt: u64,
    #[prost(uint32, tag = "12")]
    pub uid: u32,
    #[prost(uint64, tag = "13")]
    pub timeout: u64,
    #[prost(uint64, tag = "14")]
    pub inode: u64,
    #[prost(uint64, tag = "15")]
    pub r#ref: u64,
    #[prost(uint64, tag = "16")]
    pub pointer: u64,
    #[prost(message, optional, tag = "17")]
    pub process: ::core::option::Option<connect_record::Process>,
    #[prost(string, tag = "18")]
    pub netns: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ConnectRecord`.
pub mod connect_record {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Process {
        #[prost(uint32, tag = "1")]
        pub pid: u32,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Reserved = 0,
        Established = 1,
        SynSent = 2,
        SynRecv = 3,
        FinWait1 = 4,
        FinWait2 = 5,
        TimeWait = 6,
        Close = 7,
        Closewait = 8,
        Lastack = 9,
        Listen = 10,
        Closing = 11,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Reserved => "RESERVED",
                Self::Established => "ESTABLISHED",
                Self::SynSent => "SYN_SENT",
                Self::SynRecv => "SYN_RECV",
                Self::FinWait1 => "FIN_WAIT1",
                Self::FinWait2 => "FIN_WAIT2",
                Self::TimeWait => "TIME_WAIT",
                Self::Close => "CLOSE",
                Self::Closewait => "CLOSEWAIT",
                Self::Lastack => "LASTACK",
                Self::Listen => "LISTEN",
                Self::Closing => "CLOSING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESERVED" => Some(Self::Reserved),
                "ESTABLISHED" => Some(Self::Established),
                "SYN_SENT" => Some(Self::SynSent),
                "SYN_RECV" => Some(Self::SynRecv),
                "FIN_WAIT1" => Some(Self::FinWait1),
                "FIN_WAIT2" => Some(Self::FinWait2),
                "TIME_WAIT" => Some(Self::TimeWait),
                "CLOSE" => Some(Self::Close),
                "CLOSEWAIT" => Some(Self::Closewait),
                "LASTACK" => Some(Self::Lastack),
                "LISTEN" => Some(Self::Listen),
                "CLOSING" => Some(Self::Closing),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TimerActive {
        Off = 0,
        On = 1,
        Keepalive = 2,
        Timewait = 3,
        Probe = 4,
    }
    impl TimerActive {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Off => "OFF",
                Self::On => "ON",
                Self::Keepalive => "KEEPALIVE",
                Self::Timewait => "TIMEWAIT",
                Self::Probe => "PROBE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OFF" => Some(Self::Off),
                "ON" => Some(Self::On),
                "KEEPALIVE" => Some(Self::Keepalive),
                "TIMEWAIT" => Some(Self::Timewait),
                "PROBE" => Some(Self::Probe),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Netstat {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, repeated, tag = "2")]
    pub connectrecord: ::prost::alloc::vec::Vec<ConnectRecord>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetstatResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Netstat>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaWriteRequest {
    #[prost(uint32, tag = "1")]
    pub key: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaWrite {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaWriteResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<MetaWrite>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MetaDeleteRequest {
    #[prost(uint32, tag = "1")]
    pub key: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaDelete {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaDeleteResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<MetaDelete>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImageListRequest {
    /// Containerd namespace to use.
    #[prost(enumeration = "super::common::ContainerdNamespace", tag = "1")]
    pub namespace: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageListResponse {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub digest: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub size: i64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImagePullRequest {
    /// Containerd namespace to use.
    #[prost(enumeration = "super::common::ContainerdNamespace", tag = "1")]
    pub namespace: i32,
    /// Image reference to pull.
    #[prost(string, tag = "2")]
    pub reference: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImagePull {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImagePullResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<ImagePull>,
}
/// Generated client implementations.
pub mod machine_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The machine service definition.
    #[derive(Debug, Clone)]
    pub struct MachineServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MachineServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MachineServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MachineServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MachineServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn apply_configuration(
            &mut self,
            request: impl tonic::IntoRequest<super::ApplyConfigurationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ApplyConfigurationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/ApplyConfiguration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "ApplyConfiguration"));
            self.inner.unary(req, path, codec).await
        }
        /// Bootstrap method makes control plane node enter etcd bootstrap mode.
        /// Node aborts etcd join sequence and creates single-node etcd cluster.
        /// If recover_etcd argument is specified, etcd is recovered from a snapshot
        /// uploaded with EtcdRecover.
        pub async fn bootstrap(
            &mut self,
            request: impl tonic::IntoRequest<super::BootstrapRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BootstrapResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/Bootstrap",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Bootstrap"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn containers(
            &mut self,
            request: impl tonic::IntoRequest<super::ContainersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ContainersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/Containers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Containers"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn copy(
            &mut self,
            request: impl tonic::IntoRequest<super::CopyRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::super::common::Data>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/Copy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Copy"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn cpu_freq_stats(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::CpuFreqStatsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/CPUFreqStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "CPUFreqStats"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn cpu_info(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::CpuInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/CPUInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "CPUInfo"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn disk_stats(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::DiskStatsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/DiskStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "DiskStats"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn dmesg(
            &mut self,
            request: impl tonic::IntoRequest<super::DmesgRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::super::common::Data>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/Dmesg",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Dmesg"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn events(
            &mut self,
            request: impl tonic::IntoRequest<super::EventsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::Event>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/Events",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Events"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn etcd_member_list(
            &mut self,
            request: impl tonic::IntoRequest<super::EtcdMemberListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EtcdMemberListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/EtcdMemberList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "EtcdMemberList"));
            self.inner.unary(req, path, codec).await
        }
        /// EtcdRemoveMemberByID removes a member from the etcd cluster identified by member ID.
        /// This API should be used to remove members which don't have an associated Talos node anymore.
        /// To remove a member with a running Talos node, use EtcdLeaveCluster API on the node to be removed.
        pub async fn etcd_remove_member_by_id(
            &mut self,
            request: impl tonic::IntoRequest<super::EtcdRemoveMemberByIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EtcdRemoveMemberByIdResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/EtcdRemoveMemberByID",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("machine.MachineService", "EtcdRemoveMemberByID"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn etcd_leave_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::EtcdLeaveClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EtcdLeaveClusterResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/EtcdLeaveCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "EtcdLeaveCluster"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn etcd_forfeit_leadership(
            &mut self,
            request: impl tonic::IntoRequest<super::EtcdForfeitLeadershipRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EtcdForfeitLeadershipResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/EtcdForfeitLeadership",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("machine.MachineService", "EtcdForfeitLeadership"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// EtcdRecover method uploads etcd data snapshot created with EtcdSnapshot
        /// to the node.
        /// Snapshot can be later used to recover the cluster via Bootstrap method.
        pub async fn etcd_recover(
            &mut self,
            request: impl tonic::IntoStreamingRequest<
                Message = super::super::common::Data,
            >,
        ) -> std::result::Result<
            tonic::Response<super::EtcdRecoverResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/EtcdRecover",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "EtcdRecover"));
            self.inner.client_streaming(req, path, codec).await
        }
        /// EtcdSnapshot method creates etcd data snapshot (backup) from the local etcd instance
        /// and streams it back to the client.
        /// This method is available only on control plane nodes (which run etcd).
        pub async fn etcd_snapshot(
            &mut self,
            request: impl tonic::IntoRequest<super::EtcdSnapshotRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::super::common::Data>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/EtcdSnapshot",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "EtcdSnapshot"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// EtcdAlarmList lists etcd alarms for the current node.
        /// This method is available only on control plane nodes (which run etcd).
        pub async fn etcd_alarm_list(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::EtcdAlarmListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/EtcdAlarmList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "EtcdAlarmList"));
            self.inner.unary(req, path, codec).await
        }
        /// EtcdAlarmDisarm disarms etcd alarms for the current node.
        /// This method is available only on control plane nodes (which run etcd).
        pub async fn etcd_alarm_disarm(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::EtcdAlarmDisarmResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/EtcdAlarmDisarm",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "EtcdAlarmDisarm"));
            self.inner.unary(req, path, codec).await
        }
        /// EtcdDefragment defragments etcd data directory for the current node.
        /// Defragmentation is a resource-heavy operation, so it should only run on a specific
        /// node.
        /// This method is available only on control plane nodes (which run etcd).
        pub async fn etcd_defragment(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::EtcdDefragmentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/EtcdDefragment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "EtcdDefragment"));
            self.inner.unary(req, path, codec).await
        }
        /// EtcdStatus returns etcd status for the current member.
        /// This method is available only on control plane nodes (which run etcd).
        pub async fn etcd_status(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::EtcdStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/EtcdStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "EtcdStatus"));
            self.inner.unary(req, path, codec).await
        }
        /// EtcdDowngradeValidate validates etcd cluster for downgrade to a specific version.
        /// This method is available only on control plane nodes (which run etcd).
        pub async fn etcd_downgrade_validate(
            &mut self,
            request: impl tonic::IntoRequest<super::EtcdDowngradeValidateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EtcdDowngradeValidateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/EtcdDowngradeValidate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("machine.MachineService", "EtcdDowngradeValidate"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// EtcdDowngradeEnable enables etcd cluster downgrade to a specific version.
        /// This method is available only on control plane nodes (which run etcd).
        pub async fn etcd_downgrade_enable(
            &mut self,
            request: impl tonic::IntoRequest<super::EtcdDowngradeEnableRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EtcdDowngradeEnableResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/EtcdDowngradeEnable",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("machine.MachineService", "EtcdDowngradeEnable"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// EtcdDowngradeCancel cancels etcd cluster downgrade that is in progress.
        /// This method is available only on control plane nodes (which run etcd).
        pub async fn etcd_downgrade_cancel(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::EtcdDowngradeCancelResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/EtcdDowngradeCancel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("machine.MachineService", "EtcdDowngradeCancel"),
                );
            self.inner.unary(req, path, codec).await
        }
        #[deprecated]
        pub async fn generate_configuration(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateConfigurationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateConfigurationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/GenerateConfiguration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("machine.MachineService", "GenerateConfiguration"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn hostname(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::HostnameResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/Hostname",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Hostname"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn kubeconfig(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::super::common::Data>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/Kubeconfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Kubeconfig"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::FileInfo>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "List"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn disk_usage(
            &mut self,
            request: impl tonic::IntoRequest<super::DiskUsageRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::DiskUsageInfo>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/DiskUsage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "DiskUsage"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn load_avg(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::LoadAvgResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/LoadAvg",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "LoadAvg"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn logs(
            &mut self,
            request: impl tonic::IntoRequest<super::LogsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::super::common::Data>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/Logs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Logs"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn logs_containers(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::LogsContainersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/LogsContainers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "LogsContainers"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn memory(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::MemoryResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/Memory",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Memory"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn mounts(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::MountsResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/Mounts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Mounts"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn network_device_stats(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::NetworkDeviceStatsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/NetworkDeviceStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "NetworkDeviceStats"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn processes(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::ProcessesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/Processes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Processes"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn read(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::super::common::Data>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/Read",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Read"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn reboot(
            &mut self,
            request: impl tonic::IntoRequest<super::RebootRequest>,
        ) -> std::result::Result<tonic::Response<super::RebootResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/Reboot",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Reboot"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn restart(
            &mut self,
            request: impl tonic::IntoRequest<super::RestartRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RestartResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/Restart",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Restart"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn rollback(
            &mut self,
            request: impl tonic::IntoRequest<super::RollbackRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RollbackResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/Rollback",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Rollback"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn reset(
            &mut self,
            request: impl tonic::IntoRequest<super::ResetRequest>,
        ) -> std::result::Result<tonic::Response<super::ResetResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/Reset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Reset"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn service_list(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::ServiceListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/ServiceList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "ServiceList"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn service_restart(
            &mut self,
            request: impl tonic::IntoRequest<super::ServiceRestartRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ServiceRestartResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/ServiceRestart",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "ServiceRestart"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn service_start(
            &mut self,
            request: impl tonic::IntoRequest<super::ServiceStartRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ServiceStartResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/ServiceStart",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "ServiceStart"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn service_stop(
            &mut self,
            request: impl tonic::IntoRequest<super::ServiceStopRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ServiceStopResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/ServiceStop",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "ServiceStop"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn shutdown(
            &mut self,
            request: impl tonic::IntoRequest<super::ShutdownRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ShutdownResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/Shutdown",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Shutdown"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn stats(
            &mut self,
            request: impl tonic::IntoRequest<super::StatsRequest>,
        ) -> std::result::Result<tonic::Response<super::StatsResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/Stats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Stats"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn system_stat(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::SystemStatResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/SystemStat",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "SystemStat"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn upgrade(
            &mut self,
            request: impl tonic::IntoRequest<super::UpgradeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpgradeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/Upgrade",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Upgrade"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn version(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::VersionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/Version",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Version"));
            self.inner.unary(req, path, codec).await
        }
        /// GenerateClientConfiguration generates talosctl client configuration (talosconfig).
        pub async fn generate_client_configuration(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateClientConfigurationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateClientConfigurationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/GenerateClientConfiguration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "machine.MachineService",
                        "GenerateClientConfiguration",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// PacketCapture performs packet capture and streams back pcap file.
        pub async fn packet_capture(
            &mut self,
            request: impl tonic::IntoRequest<super::PacketCaptureRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::super::common::Data>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/PacketCapture",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "PacketCapture"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Netstat provides information about network connections.
        pub async fn netstat(
            &mut self,
            request: impl tonic::IntoRequest<super::NetstatRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NetstatResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/Netstat",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Netstat"));
            self.inner.unary(req, path, codec).await
        }
        /// MetaWrite writes a META key-value pair.
        pub async fn meta_write(
            &mut self,
            request: impl tonic::IntoRequest<super::MetaWriteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MetaWriteResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/MetaWrite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "MetaWrite"));
            self.inner.unary(req, path, codec).await
        }
        /// MetaDelete deletes a META key.
        pub async fn meta_delete(
            &mut self,
            request: impl tonic::IntoRequest<super::MetaDeleteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MetaDeleteResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/MetaDelete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "MetaDelete"));
            self.inner.unary(req, path, codec).await
        }
        /// ImageList lists images in the CRI.
        pub async fn image_list(
            &mut self,
            request: impl tonic::IntoRequest<super::ImageListRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ImageListResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/ImageList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "ImageList"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// ImagePull pulls an image into the CRI.
        pub async fn image_pull(
            &mut self,
            request: impl tonic::IntoRequest<super::ImagePullRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ImagePullResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/ImagePull",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "ImagePull"));
            self.inner.unary(req, path, codec).await
        }
    }
}
